# 18键共键输入与滑动精确输入方案

## 概述

本文档记录了在 Trime（同文输入法）上实现手心输入法风格的18键布局的技术方案。核心功能包括：

1. **共键模糊输入**：点击共键时，同时匹配两个字母的候选
2. **滑动精确输入**：滑动共键时，只匹配滑动方向对应的字母

## 第一阶段：使用 speller/algebra 实现模糊输入

### 问题背景

标准26键布局在手机上按键过小，手心输入法使用18键布局，将部分相邻字母合并为一个键。用户希望在 Trime 上实现类似功能。

### 键盘布局

```
第一行：Q(独立), WE, RT, Y(独立), U(独立), IO, P(独立)
第二行：A(独立), SD, FG, H(独立), JK, L(独立)
第三行：Z(独立), XC, V(独立), BN, M(独立)
```

### 技术方案

在 `moqi_xh-trime.custom.yaml` 中使用 `speller/algebra` 的 `derive` 规则实现双向模糊匹配：

```yaml
"speller/algebra/+":
  # WE 共键：W 和 E 互相模糊
  - derive/^w/e/      # 输入 e 可匹配 w 开头的词
  - derive/w$/e/      # 输入 e 可匹配 w 结尾的词
  - derive/^e/w/      # 输入 w 可匹配 e 开头的词
  - derive/e$/w/      # 输入 w 可匹配 e 结尾的词
  
  # RT 共键、IO 共键、SD 共键、FG 共键、JK 共键、XC 共键、BN 共键...
```

### 实现效果

- ✅ 点击 WE 键发送 `w`，候选列表同时出现 `w` 和 `e` 的词
- ❌ 无法区分点击和滑动输入，滑动精确输入时仍显示模糊候选

### 局限性

`speller/algebra` 规则在部署时生成，运行时无法动态切换。这意味着无论用户如何输入，模糊匹配始终生效。

## 第二阶段：使用 Lua 实现滑动精确输入

### 问题分析

要实现滑动精确输入，需要：
1. 区分点击和滑动操作（键盘层面）
2. 在运行时过滤模糊候选（Lua 层面）

### 技术方案

#### 2.1 键盘层面：滑动发送大写字母

在 `shouxin_18key.trime.yaml` 中配置共键的滑动行为：

```yaml
# 共键示例：WE
- {click: key_WE, swipe_left: W, swipe_right: E, ...}

# 其中 key_WE 定义为：
key_WE:
  label: "WE"
  send: w  # 点击发送小写 w
```

- **点击**：发送小写字母 `w`（触发模糊匹配）
- **滑动**：发送大写字母 `W` 或 `E`（作为精确输入标记）

#### 2.2 Lua Processor：拦截大写字母

创建 `lua/precise_input_processor.lua`，拦截大写字母输入：

```lua
local rime = require "sbxlm.lib"

local function processor(key, env)
    if key:release() or key:alt() or key:ctrl() or key:caps() then
        return rime.process_results.kNoop
    end
    
    local keycode = key.keycode
    local context = env.engine.context
    
    -- 检查是否是大写字母 (A=65, Z=90)
    if keycode >= 65 and keycode <= 90 then
        -- 转换为小写字母
        local char = utf8.char(keycode + 32)
        
        -- 记录精确输入位置
        local pos = #context.input + 1
        local precise_map = context:get_property("precise_input_map") or ""
        if #precise_map > 0 then
            precise_map = precise_map .. "," .. tostring(pos)
        else
            precise_map = tostring(pos)
        end
        context:set_property("precise_input_map", precise_map)
        
        -- 追加小写字母到输入
        context:push_input(char)
        return rime.process_results.kAccepted
    end
    
    return rime.process_results.kNoop
end

return processor
```

#### 2.3 Lua Filter：使用 ReverseLookup 反查过滤

创建 `lua/precise_input_filter.lua`，使用反查获取候选的真实拼音并过滤：

```lua
-- 18键共键映射：模糊对关系
local fuzzy_pairs = {
    w = "e", e = "w",
    r = "t", t = "r",
    i = "o", o = "i",
    s = "d", d = "s",
    f = "g", g = "f",
    j = "k", k = "j",
    x = "c", c = "x",
    b = "n", n = "b",
}

local function filter(input, env)
    -- 获取精确输入记录
    local precise_map_str = context:get_property("precise_input_map") or ""
    
    -- 如果没有精确输入记录，直接输出所有候选
    if not next(precise_positions) then
        for cand in input:iter() do
            yield(cand)
        end
        return
    end
    
    -- 使用 ReverseLookup 反查每个候选字
    for cand in input:iter() do
        -- 对候选文字逐字反查，获取真实拼音
        local cand_pinyin = reversedb:lookup(cand_char)
        
        -- 比较首字母，如果是模糊对则过滤
        if user_char ~= cand_first_char then
            local fuzzy_match = fuzzy_pairs[user_char]
            if fuzzy_match and fuzzy_match == cand_first_char then
                -- 过滤掉模糊候选
                goto continue
            end
        end
        
        yield(cand)
        ::continue::
    end
end

return filter
```

#### 2.4 Schema 配置

在 `moqi_xh-trime.custom.yaml` 中注册 Processor 和 Filter：

```yaml
"engine/processors":
  - lua_processor@*precise_input_processor  # 必须在最前
  - ascii_composer
  - recognizer
  - ...

"engine/filters/+":
  - lua_filter@*precise_input_filter
```

## 最终架构

```
用户操作
    ↓
键盘层面
    ├── 点击共键：发送小写字母（如 w）
    └── 滑动共键：发送大写字母（如 W 或 E）
    ↓
Lua Processor
    ├── 小写字母：不处理，交给 speller
    └── 大写字母：转为小写 + 记录精确位置到 context.property
    ↓
Speller + 模糊规则
    └── 生成包含模糊候选的结果（无论点击还是滑动）
    ↓
Lua Filter
    ├── 无精确标记：输出所有候选（点击时的模糊匹配）
    └── 有精确标记：
        ├── 使用 ReverseLookup 反查候选字的真实拼音
        ├── 比较首字母与用户输入
        └── 过滤不匹配的模糊候选
    ↓
用户看到候选列表
```

## 相关文件

| 文件 | 作用 |
|------|------|
| `shouxin_18key.trime.yaml` | 键盘布局，定义共键滑动发送大写字母 |
| `moqi_xh-trime.custom.yaml` | speller 模糊规则 + Processor/Filter 注册 |
| `lua/precise_input_processor.lua` | 拦截大写字母，记录精确输入位置 |
| `lua/precise_input_filter.lua` | 使用 ReverseLookup 反查过滤模糊候选 |
| `lua/sbxlm/lib.lua` | Rime Lua API 类型定义（依赖库） |

## 参考资料与致谢

本方案的实现参考了以下开源项目和资源：

### librime-lua API
- **项目**：[hchunhui/librime-lua](https://github.com/hchunhui/librime-lua)
- **文档**：[Scripting Wiki](https://github.com/hchunhui/librime-lua/wiki/Scripting)
- **用途**：了解 Rime Lua 插件的 API，如 `context:push_input()`, `context:get_property()` 等

### 声笔系列输入法 (sbxlm)
- **项目**：声笔系列输入法
- **参考文件**：
  - `lua/sbxlm/lib.lua` - Rime Lua API 的完整类型定义
  - `lua/sbxlm/upper_case.lua` - 大写字母处理的参考实现
- **用途**：学习 Processor 的正确 API 使用方式

### cold_word_drop 冷词下沉
- **项目**：冷词下沉 Lua 插件
- **参考文件**：
  - `lua/cold_word_drop/processor.lua` - ReverseLookup 的正确用法
  - `lua/cold_word_drop/filter.lua` - Filter 的实现模式
- **用途**：学习如何使用 `ReverseLookup` 对候选文字进行反查获取拼音

### 墨奇输入法 (Moqi)
- **项目**：墨奇输入法方案
- **用途**：基础输入方案 `moqi_xh.schema.yaml`

### Trime (同文输入法)
- **项目**：[osfans/trime](https://github.com/osfans/trime)
- **参考文件**：`tongwenfeng.trime.yaml` - 键盘布局和液态键盘配置
- **用途**：学习 Trime 的键盘配置语法

## 版本历史

| 版本 | 日期 | 说明 |
|------|------|------|
| v1.0 | 2026-01-02 | 实现 speller 模糊规则，支持点击共键模糊输入 |
| v2.0 | 2026-01-03 | 添加 Lua Processor，尝试使用 context.property 传递精确标记 |
| v3.0 | 2026-01-03 | 添加 Lua Filter，使用 ReverseLookup 反查过滤，完整实现滑动精确输入 |
