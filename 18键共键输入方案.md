# 18键共键输入与滑动精确输入方案

## 概述

本文档记录了在 Trime（同文输入法）上实现手心输入法风格的18键布局的技术方案。核心功能包括：

1. **共键模糊输入**：点击共键时，同时匹配两个字母的候选
2. **滑动精确输入**：滑动共键时，只匹配滑动方向对应的字母
3. **混合输入支持**：点击和滑动混合使用时，正确处理模糊和精确位置

## 第一阶段：使用 speller/algebra 实现模糊输入

### 问题背景

标准26键布局在手机上按键过小，手心输入法使用18键布局，将部分相邻字母合并为一个键。用户希望在 Trime 上实现类似功能。

### 键盘布局

```
第一行：Q(独立), WE, RT, Y(独立), U(独立), IO, P(独立)
第二行：A(独立), SD, FG, H(独立), JK, L(独立)
第三行：Z(独立), XC, V(独立), BN, M(独立)
```

### 技术方案

在 `moqi_xh-trime.custom.yaml` 中使用 `speller/algebra` 的 `derive` 规则实现双向模糊匹配：

```yaml
"speller/algebra/+":
  # WE 共键：W 和 E 互相模糊
  - derive/^w/e/      # 输入 e 可匹配 w 开头的词
  - derive/w$/e/      # 输入 e 可匹配 w 结尾的词
  - derive/^e/w/      # 输入 w 可匹配 e 开头的词
  - derive/e$/w/      # 输入 w 可匹配 e 结尾的词
  
  # RT 共键、IO 共键、SD 共键、FG 共键、JK 共键、XC 共键、BN 共键...
```

### 实现效果

- ✅ 点击 WE 键发送 `w`，候选列表同时出现 `w` 和 `e` 的词
- ❌ 无法区分点击和滑动输入，滑动精确输入时仍显示模糊候选

### 局限性

`speller/algebra` 规则在部署时生成，运行时无法动态切换。这意味着无论用户如何输入，模糊匹配始终生效。

## 第二阶段：使用 Lua 实现滑动精确输入

### 问题分析

要实现滑动精确输入，需要：
1. 区分点击和滑动操作（键盘层面）
2. 在运行时过滤模糊候选（Lua 层面）

### 技术方案

#### 2.1 键盘层面：滑动发送大写字母

在 `shouxin_18key.trime.yaml` 中配置共键的滑动行为：

```yaml
# 共键示例：WE
- {click: key_WE, swipe_left: W, swipe_right: E, ...}

# 其中 key_WE 定义为：
key_WE:
  label: "WE"
  send: w  # 点击发送小写 w
```

- **点击**：发送小写字母 `w`（触发模糊匹配）
- **滑动**：发送大写字母 `W` 或 `E`（作为精确输入标记）

#### 2.2 Lua Processor：拦截大写字母

创建 `lua/precise_input_processor.lua`，拦截大写字母输入：

```lua
local rime = require "sbxlm.lib"

local function processor(key, env)
    if key:release() or key:alt() or key:ctrl() or key:caps() then
        return rime.process_results.kNoop
    end
    
    local keycode = key.keycode
    local context = env.engine.context
    
    -- 检查是否是大写字母 (A=65, Z=90)
    if keycode >= 65 and keycode <= 90 then
        -- 转换为小写字母
        local char = utf8.char(keycode + 32)
        
        -- 记录精确输入位置（字符级别）
        local pos = #context.input + 1
        local precise_map = context:get_property("precise_input_map") or ""
        if #precise_map > 0 then
            precise_map = precise_map .. "," .. tostring(pos)
        else
            precise_map = tostring(pos)
        end
        context:set_property("precise_input_map", precise_map)
        
        -- 追加小写字母到输入
        context:push_input(char)
        return rime.process_results.kAccepted
    end
    
    return rime.process_results.kNoop
end

return processor
```

#### 2.3 Lua Filter：使用 ReverseLookup 反查过滤

创建 `lua/precise_input_filter.lua`，使用反查获取候选的真实拼音并过滤。

## 第三阶段：修复混合输入问题

### 问题发现

v3 版本在单纯精确输入（如连续滑动 EE）时工作正常，但在**混合输入**（点击+滑动）时出现问题：

**场景**：用户在 WE 键上 `点击(w) + 滑动(E)`
- 发送：`w` + `E` → 变成 `we`
- 第1个字符是模糊输入（无精确标记）
- 第2个字符是精确输入（标记位置2）

**问题**：v3 版本按**音节**检查精确匹配，而不是按**字符**。导致 `we` 中的第2字符 `e` 没有被正确验证。

### v4 解决方案

修改 Filter 为**字符级别**的精确匹配：

```lua
-- v4 核心逻辑：
-- 精确位置记录的是字符位置（1, 2, 3...），而不是音节位置
-- 检查时按字符位置验证

-- 计算字符在原始输入中的位置
local char_pos1 = (syllable_pos - 1) * 2 + 1  -- 第1个字符
local char_pos2 = (syllable_pos - 1) * 2 + 2  -- 第2个字符

-- 检查第2个字符
if precise_positions[char_pos2] then
    -- 精确输入位置：必须完全匹配
    if user_char2 ~= cand_char2 then
        return false  -- 精确输入不匹配，过滤
    end
end
```

### 混合输入测试用例

| 操作 | 发送 | 精确位置 | 预期候选 |
|------|------|----------|----------|
| 点击+点击 | ww | 无 | we, ww, ee, ew (全部模糊) |
| 滑动E+滑动E | EE | {1,2} | 只有 ee |
| 点击+滑动E | wE | {2} | we, ee (第2位必须是e) |
| 滑动E+点击 | Ew | {1} | ew, ee (第1位必须是e) |

## 第四阶段：禁用超级简拼

### 问题发现

超级简拼（`custom_phrase_super_1jian`, `custom_phrase_super_2jian`, `custom_phrase_super_3jian`）会在1-3个字符输入时产生大量候选，干扰精确输入判断。

### 解决方案

在 `moqi_xh-trime.custom.yaml` 中禁用超级简拼：

```yaml
"engine/translators":
  # 超级简拼会影响18键精确输入判断，禁用
  # - table_translator@custom_phrase_super_1jian
  # - table_translator@custom_phrase_super_2jian
  # - table_translator@custom_phrase_super_3jian
```

## 最终架构

```
用户操作
    ↓
键盘层面
    ├── 点击共键：发送小写字母（如 w）
    └── 滑动共键：发送大写字母（如 W 或 E）
    ↓
Lua Processor
    ├── 小写字母：不处理，交给 speller
    └── 大写字母：转为小写 + 记录精确位置（字符级别）到 context.property
    ↓
Speller + 模糊规则
    └── 生成包含模糊候选的结果（无论点击还是滑动）
    ↓
Lua Filter (v4)
    ├── 无精确标记：输出所有候选（点击时的模糊匹配）
    └── 有精确标记：
        ├── 使用 ReverseLookup 反查候选字的真实拼音
        ├── 按字符位置比较用户输入与候选拼音
        ├── 精确位置：必须完全匹配
        ├── 模糊位置：可以匹配原字符或模糊对
        └── 过滤不匹配的候选
    ↓
用户看到候选列表
```

## 相关文件

| 文件 | 作用 |
|------|------|
| `shouxin_18key.trime.yaml` | 键盘布局，定义共键滑动发送大写字母 |
| `moqi_xh-trime.custom.yaml` | speller 模糊规则 + Processor/Filter 注册 + 禁用超级简拼 |
| `lua/precise_input_processor.lua` | 拦截大写字母，记录精确输入位置（字符级别） |
| `lua/precise_input_filter.lua` | 使用 ReverseLookup 反查过滤模糊候选（v4：字符级别匹配） |
| `lua/sbxlm/lib.lua` | Rime Lua API 类型定义（依赖库） |

## 参考资料与致谢

本方案的实现参考了以下开源项目和资源：

### librime-lua API
- **项目**：[hchunhui/librime-lua](https://github.com/hchunhui/librime-lua)
- **文档**：[Scripting Wiki](https://github.com/hchunhui/librime-lua/wiki/Scripting)
- **用途**：了解 Rime Lua 插件的 API，如 `context:push_input()`, `context:get_property()` 等

### 声笔系列输入法 (sbxlm)
- **项目**：声笔系列输入法
- **参考文件**：
  - `lua/sbxlm/lib.lua` - Rime Lua API 的完整类型定义
  - `lua/sbxlm/upper_case.lua` - 大写字母处理的参考实现
- **用途**：学习 Processor 的正确 API 使用方式

### cold_word_drop 冷词下沉
- **项目**：冷词下沉 Lua 插件
- **参考文件**：
  - `lua/cold_word_drop/processor.lua` - ReverseLookup 的正确用法
  - `lua/cold_word_drop/filter.lua` - Filter 的实现模式
- **用途**：学习如何使用 `ReverseLookup` 对候选文字进行反查获取拼音

### 墨奇输入法 (Moqi)
- **项目**：墨奇输入法方案
- **用途**：基础输入方案 `moqi_xh.schema.yaml`

### Trime (同文输入法)
- **项目**：[osfans/trime](https://github.com/osfans/trime)
- **参考文件**：`tongwenfeng.trime.yaml` - 键盘布局和液态键盘配置
- **用途**：学习 Trime 的键盘配置语法

## 版本历史

| 版本 | 日期 | 说明 |
|------|------|------|
| v1.0 | 2026-01-02 | 实现 speller 模糊规则，支持点击共键模糊输入 |
| v2.0 | 2026-01-03 | 添加 Lua Processor，尝试使用 context.property 传递精确标记 |
| v3.0 | 2026-01-03 | 添加 Lua Filter，使用 ReverseLookup 反查过滤，实现滑动精确输入 |
| v4.0 | 2026-01-03 | 修复混合输入问题：改为字符级别精确匹配；禁用超级简拼 |
